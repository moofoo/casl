{"version":3,"file":"index.js","sources":["../../src/errors/ParsingQueryError.ts","../../src/prisma/PrismaQueryParser.ts","../../src/prisma/interpretPrismaQuery.ts","../../src/prisma/PrismaQuery.ts","../../src/accessibleBy.ts","../../src/PrismaAbility.ts"],"sourcesContent":["export class ParsingQueryError extends Error {\n  static invalidArgument(operatorName: string, value: unknown, expectValueType: string) {\n    const valueType = `${typeof value}(${JSON.stringify(value, null, 2)})`;\n    return new this(\n      `\"${operatorName}\" expects to receive ${expectValueType} but instead got \"${valueType}\"`\n    );\n  }\n}\n","import {\n  buildAnd,\n  Comparable,\n  CompoundCondition,\n  CompoundInstruction,\n  Condition,\n  FieldCondition,\n  FieldInstruction,\n  FieldParsingContext,\n  NULL_CONDITION,\n  ObjectQueryFieldParsingContext,\n  ObjectQueryParser\n} from '@ucast/core';\nimport { ParsingQueryError } from '../errors/ParsingQueryError';\n\nconst isPlainObject = (value: any) => {\n  return value && (value.constructor === Object || !value.constructor);\n};\n\nconst equals: FieldInstruction = {\n  type: 'field',\n  validate(instruction, value) {\n    if (Array.isArray(value) || isPlainObject(value)) {\n      throw new ParsingQueryError(`\"${instruction.name}\" does not supports comparison of arrays and objects`);\n    }\n  }\n};\n\nconst not: FieldInstruction<unknown, ObjectQueryFieldParsingContext> = {\n  type: 'field',\n  parse(instruction, value, { hasOperators, field, parse }) {\n    if (isPlainObject(value) && !hasOperators(value) || Array.isArray(value)) {\n      throw new ParsingQueryError(`\"${instruction.name}\" does not supports comparison of arrays and objects`);\n    }\n\n    if (!isPlainObject(value)) {\n      return new FieldCondition('notEquals', field, value);\n    }\n\n    return new CompoundCondition('NOT', [parse(value, { field })]);\n  }\n};\n\nconst within: FieldInstruction<unknown[]> = {\n  type: 'field',\n  validate(instruction, value) {\n    if (!Array.isArray(value)) {\n      throw ParsingQueryError.invalidArgument(instruction.name, value, 'an array');\n    }\n  }\n};\n\nconst lt: FieldInstruction<Comparable> = {\n  type: 'field',\n  validate(instruction, value) {\n    const type = typeof value;\n    const isComparable = type === 'string'\n      || type === 'number' && Number.isFinite(value)\n      || value instanceof Date;\n\n    if (!isComparable) {\n      throw ParsingQueryError.invalidArgument(instruction.name, value, 'comparable value');\n    }\n  }\n};\n\nconst POSSIBLE_MODES = new Set(['insensitive', 'default']);\nconst mode: FieldInstruction<string> = {\n  type: 'field',\n  validate(instruction, value) {\n    if (!POSSIBLE_MODES.has(value)) {\n      throw ParsingQueryError.invalidArgument(\n        instruction.name,\n        value,\n        `one of ${Array.from(POSSIBLE_MODES).join(', ')}`\n      );\n    }\n  },\n  parse: () => NULL_CONDITION\n};\n\ninterface StringFieldContext extends FieldParsingContext {\n  query: {\n    mode?: 'insensitive'\n  }\n}\n\nconst compareString: FieldInstruction<string, StringFieldContext> = {\n  type: 'field',\n  validate(instruction, value) {\n    if (typeof value !== 'string') {\n      throw ParsingQueryError.invalidArgument(instruction.name, value, 'string');\n    }\n  },\n  parse(instruction, value, { query, field }) {\n    const name = query.mode === 'insensitive' ? `i${instruction.name}` : instruction.name;\n    return new FieldCondition(name, field, value);\n  }\n};\n\nconst compound: CompoundInstruction = {\n  type: 'compound',\n  validate(instruction, value) {\n    if (!value || typeof value !== 'object') {\n      throw ParsingQueryError.invalidArgument(instruction.name, value, 'an array or object');\n    }\n  },\n  parse(instruction, arrayOrObject, { parse }) {\n    const value = Array.isArray(arrayOrObject) ? arrayOrObject : [arrayOrObject];\n    const conditions = value.map(v => parse(v));\n    return new CompoundCondition(instruction.name, conditions);\n  }\n};\n\nconst isEmpty: FieldInstruction<boolean> = {\n  type: 'field',\n  validate(instruction, value) {\n    if (typeof value !== 'boolean') {\n      throw ParsingQueryError.invalidArgument(instruction.name, value, 'a boolean');\n    }\n  }\n};\n\nconst has: FieldInstruction<unknown> = {\n  type: 'field'\n};\n\nconst hasSome: FieldInstruction<unknown[]> = {\n  type: 'field',\n  validate(instruction, value) {\n    if (!Array.isArray(value)) {\n      throw ParsingQueryError.invalidArgument(instruction.name, value, 'an array');\n    }\n  }\n};\n\nconst relation: FieldInstruction<Record<string, unknown>, ObjectQueryFieldParsingContext> = {\n  type: 'field',\n  parse(instruction, value, { field, parse }) {\n    if (!isPlainObject(value)) {\n      throw ParsingQueryError.invalidArgument(instruction.name, value, 'a query for nested relation');\n    }\n\n    return new FieldCondition(instruction.name, field, parse(value));\n  }\n};\n\nconst inverted = (name: string, baseInstruction: FieldInstruction): FieldInstruction => {\n  const parse = baseInstruction.parse;\n\n  if (!parse) {\n    return {\n      ...baseInstruction,\n      parse(_, value, ctx) {\n        return new CompoundCondition('NOT', [new FieldCondition(name, ctx.field, value)]);\n      }\n    };\n  }\n\n  return {\n    ...baseInstruction,\n    parse(instruction, value, ctx) {\n      const condition = parse(instruction, value, ctx);\n      if (condition.operator !== instruction.name) {\n        throw new Error(`Cannot invert \"${name}\" operator parser because it returns a complex Condition`);\n      }\n      (condition as Mutable<Condition>).operator = name;\n      return new CompoundCondition('NOT', [condition]);\n    }\n  };\n};\n\nconst instructions = {\n  equals,\n  not,\n  in: within,\n  notIn: inverted('in', within),\n  lt,\n  lte: lt,\n  gt: lt,\n  gte: lt,\n  mode,\n  startsWith: compareString,\n  endsWith: compareString,\n  contains: compareString,\n  isEmpty,\n  has,\n  hasSome,\n  hasEvery: hasSome,\n  NOT: compound,\n  AND: compound,\n  OR: compound,\n  every: relation,\n  some: relation,\n  none: inverted('some', relation),\n  is: relation,\n  isNot: inverted('is', relation),\n};\n\nexport interface ParseOptions {\n  field: string\n}\n\ntype Query = Record<string, any>;\nexport class PrismaQueryParser extends ObjectQueryParser<Query> {\n  constructor() {\n    super(instructions, {\n      defaultOperatorName: 'equals',\n    });\n  }\n\n  parse(query: Query, options?: ParseOptions): Condition {\n    if (options && options.field) {\n      return buildAnd(this.parseFieldOperators(options.field, query));\n    }\n\n    return super.parse(query);\n  }\n}\n\ntype Mutable<T> = { -readonly [K in keyof T]: T[K] };\n","import { CompoundCondition, Condition, FieldCondition } from '@ucast/core';\nimport {\n  JsInterpreter,\n  createJsInterpreter,\n  eq,\n  ne,\n  and,\n  or,\n  within,\n  lt,\n  lte,\n  gt,\n  gte,\n  compare\n} from '@ucast/js';\n\ntype StringInterpreter = JsInterpreter<FieldCondition<string>, Record<string, string>>;\nconst startsWith: StringInterpreter = (condition, object, { get }) => {\n  return get(object, condition.field).startsWith(condition.value);\n};\nconst istartsWith: StringInterpreter = (condition, object, { get }) => {\n  return get(object, condition.field).toLowerCase().startsWith(condition.value.toLowerCase());\n};\n\nconst endsWith: StringInterpreter = (condition, object, { get }) => {\n  return get(object, condition.field).endsWith(condition.value);\n};\nconst iendsWith: StringInterpreter = (condition, object, { get }) => {\n  return get(object, condition.field).toLowerCase().endsWith(condition.value.toLowerCase());\n};\n\nconst contains: StringInterpreter = (condition, object, { get }) => {\n  return get(object, condition.field).includes(condition.value);\n};\nconst icontains: StringInterpreter = (condition, object, { get }) => {\n  return get(object, condition.field).toLowerCase().includes(condition.value.toLowerCase());\n};\n\ntype ArrayInterpreter<\n  TConditionValue,\n  TValue extends Record<string, unknown[]> = Record<string, unknown[]>\n> = JsInterpreter<FieldCondition<TConditionValue>, TValue>;\nconst isEmpty: ArrayInterpreter<boolean> = (condition, object, { get }) => {\n  const value = get(object, condition.field);\n  const empty = Array.isArray(value) && value.length === 0;\n  return empty === condition.value;\n};\nconst has: ArrayInterpreter<unknown> = (condition, object, { get }) => {\n  const value = get(object, condition.field);\n  return Array.isArray(value) && value.includes(condition.value);\n};\nconst hasSome: ArrayInterpreter<unknown[]> = (condition, object, { get }) => {\n  const value = get(object, condition.field);\n  return Array.isArray(value) && condition.value.some(v => value.includes(v));\n};\nconst hasEvery: ArrayInterpreter<unknown[]> = (condition, object, { get }) => {\n  const value = get(object, condition.field);\n  return Array.isArray(value) && condition.value.every(v => value.includes(v));\n};\n\nconst every: JsInterpreter<FieldCondition<Condition>> = (condition, object, { get, interpret }) => {\n  const items = get(object, condition.field) as Record<string, unknown>[];\n  return Array.isArray(items)\n    && items.length > 0\n    && items.every(item => interpret(condition.value, item));\n};\n\nconst some: JsInterpreter<FieldCondition<Condition>> = (condition, object, { get, interpret }) => {\n  const items = get(object, condition.field) as Record<string, unknown>[];\n  return Array.isArray(items) && items.some(item => interpret(condition.value, item));\n};\n\nconst is: JsInterpreter<FieldCondition<Condition>> = (condition, object, { get, interpret }) => {\n  const item = get(object, condition.field) as Record<string, unknown>;\n  return item && typeof item === 'object' && interpret(condition.value, item);\n};\n\nconst not: JsInterpreter<CompoundCondition> = (condition, object, { interpret }) => {\n  return condition.value.every(subCondition => !interpret(subCondition, object));\n};\n\nfunction toComparable(value: unknown) {\n  return value && typeof value === 'object' ? value.valueOf() : value;\n}\n\nconst compareValues: typeof compare = (a, b) => compare(toComparable(a), toComparable(b));\n\nexport const interpretPrismaQuery = createJsInterpreter({\n  // TODO: support arrays and objects comparison\n  equals: eq,\n  notEquals: ne,\n  in: within,\n  lt,\n  lte,\n  gt,\n  gte,\n  startsWith,\n  istartsWith,\n  endsWith,\n  iendsWith,\n  contains,\n  icontains,\n  isEmpty,\n  has,\n  hasSome,\n  hasEvery,\n  and,\n  or,\n  AND: and,\n  OR: or,\n  NOT: not,\n  every,\n  some,\n  is,\n}, {\n  get: (object, field) => object[field],\n  compare: compareValues,\n});\n","import { PrismaClient, Prisma } from '@prisma/client';\nimport { AnyInterpreter, createTranslatorFactory } from '@ucast/core';\nimport { ForcedSubject, hkt } from '@casl/ability';\nimport { PrismaQueryParser } from './PrismaQueryParser';\nimport { interpretPrismaQuery } from './interpretPrismaQuery';\n\ntype ModelDelegates = {\n  [K in Prisma.ModelName]: Uncapitalize<K> extends keyof PrismaClient\n    ? PrismaClient[Uncapitalize<K>]\n    : never\n};\ntype Present<T> = Exclude<T, null | undefined>;\nexport type WhereInput<TModelName extends Prisma.ModelName> =\n  Present<Present<Parameters<ModelDelegates[TModelName]['findFirst']>[0]>['where']>;\ntype ExtractModelName<T> = T extends { kind: Prisma.ModelName }\n  ? T['kind']\n  : T extends ForcedSubject<Prisma.ModelName>\n    ? T['__caslSubjectType__']\n    : T extends { __typename: Prisma.ModelName }\n      ? T['__typename']\n      : never;\n\ninterface PrismaQueryTypeFactory extends hkt.GenericFactory {\n  produce: WhereInput<ExtractModelName<this[0]>>\n}\n\nexport type Model<T, TName extends string> = T & ForcedSubject<TName>;\nexport type Subjects<T extends Record<Prisma.ModelName, Record<string, unknown>>> =\n  | keyof T\n  | { [K in keyof T]: Model<T[K], K & string> }[keyof T];\n\ntype PrismaModel = Model<Record<string, any>, Prisma.ModelName>;\nexport type PrismaQuery<T extends PrismaModel = PrismaModel> =\n  WhereInput<ExtractModelName<T>> & hkt.Container<PrismaQueryTypeFactory>;\n\nconst parser = new PrismaQueryParser();\nexport const prismaQuery = createTranslatorFactory(\n  parser.parse,\n  interpretPrismaQuery as AnyInterpreter\n);\n","import { Prisma } from '@prisma/client';\nimport { rulesToQuery } from '@casl/ability/extra';\nimport { AnyAbility, ForbiddenError } from '@casl/ability';\nimport { PrismaAbility } from './PrismaAbility';\nimport { WhereInput } from './prisma/PrismaQuery';\n\nfunction convertToPrismaQuery(rule: AnyAbility['rules'][number]) {\n  return rule.inverted ? { NOT: rule.conditions } : rule.conditions;\n}\n\nconst proxyHandlers: ProxyHandler<{ _ability: AnyAbility, _action: string }> = {\n  get(target, subjectType) {\n    const query = rulesToQuery(target._ability, target._action, subjectType, convertToPrismaQuery);\n\n    if (query === null) {\n      const error = ForbiddenError.from(target._ability)\n        .setMessage(`It's not allowed to run \"${target._action}\" on \"${subjectType as string}\"`);\n      error.action = target._action;\n      error.subjectType = error.subject = subjectType as string;\n      throw error;\n    }\n\n    const prismaQuery = Object.create(null);\n\n    if (query.$or) {\n      prismaQuery.OR = query.$or;\n    }\n\n    if (query.$and) {\n      prismaQuery.AND = query.$and;\n    }\n\n    return prismaQuery;\n  }\n};\nfunction createQuery(ability: PrismaAbility, action: string) {\n  return new Proxy({\n    _ability: ability,\n    _action: action\n  }, proxyHandlers) as unknown as AccessibleQuery;\n}\n\ntype AccessibleQuery = {\n  [K in Prisma.ModelName]: WhereInput<K>;\n};\n\nexport function accessibleBy(ability: PrismaAbility<any, any>, action = 'read'): AccessibleQuery {\n  return createQuery(ability, action);\n}\n","import { Prisma } from '@prisma/client';\nimport { AbilityOptions, AbilityTuple, fieldPatternMatcher, PureAbility, RawRuleFrom } from '@casl/ability';\nimport { PrismaQuery, prismaQuery } from './prisma/PrismaQuery';\n\nexport class PrismaAbility<\n  A extends AbilityTuple = [string, Prisma.ModelName],\n  C extends PrismaQuery = PrismaQuery\n> extends PureAbility<A, C> {\n  constructor(rules?: RawRuleFrom<A, C>[], options?: AbilityOptions<A, C>) {\n    super(rules, {\n      conditionsMatcher: prismaQuery,\n      fieldMatcher: fieldPatternMatcher,\n      ...options,\n    });\n  }\n}\n"],"names":["ParsingQueryError","Error","invalidArgument","operatorName","value","expectValueType","valueType","JSON","stringify","isPlainObject","constructor","Object","equals","type","validate","instruction","Array","isArray","name","not","parse","hasOperators","field","FieldCondition","CompoundCondition","within","lt","isComparable","Number","isFinite","Date","POSSIBLE_MODES","Set","mode","has","from","join","NULL_CONDITION","compareString","query","compound","arrayOrObject","conditions","map","v","isEmpty","hasSome","relation","inverted","baseInstruction","_","ctx","condition","operator","instructions","in","notIn","lte","gt","gte","startsWith","endsWith","contains","hasEvery","NOT","AND","OR","every","some","none","is","isNot","PrismaQueryParser","ObjectQueryParser","defaultOperatorName","options","buildAnd","parseFieldOperators","object","get","istartsWith","toLowerCase","iendsWith","includes","icontains","empty","length","interpret","items","item","subCondition","toComparable","valueOf","compareValues","a","b","compare","interpretPrismaQuery","createJsInterpreter","eq","notEquals","ne","and","or","parser","prismaQuery","createTranslatorFactory","convertToPrismaQuery","rule","proxyHandlers","target","subjectType","rulesToQuery","_ability","_action","error","ForbiddenError","setMessage","action","subject","create","$or","$and","createQuery","ability","Proxy","accessibleBy","PrismaAbility","PureAbility","rules","conditionsMatcher","fieldMatcher","fieldPatternMatcher"],"mappings":"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"}