{"version":3,"file":"extra.js","sources":["../../src/utils.ts","../../src/extra.ts"],"sourcesContent":["import { AnyObject, Subject, SubjectType, SubjectClass, ForcedSubject, AliasesMap } from './types';\n\nexport function wrapArray<T>(value: T[] | T): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n\nexport function setByPath(object: AnyObject, path: string, value: unknown): void {\n  let ref = object;\n  let lastKey = path;\n\n  if (path.indexOf('.') !== -1) {\n    const keys = path.split('.');\n\n    lastKey = keys.pop()!;\n    ref = keys.reduce((res, prop) => {\n      res[prop] = res[prop] || {};\n      return res[prop] as AnyObject;\n    }, object);\n  }\n\n  ref[lastKey] = value;\n}\n\nconst TYPE_FIELD = '__caslSubjectType__';\nexport function setSubjectType<\n  T extends string,\n  U extends Record<PropertyKey, any>\n>(type: T, object: U): U & ForcedSubject<T> {\n  if (object) {\n    if (!object.hasOwnProperty(TYPE_FIELD)) {\n      Object.defineProperty(object, TYPE_FIELD, { value: type });\n    } else if (type !== object[TYPE_FIELD]) {\n      throw new Error(`Trying to cast object to subject type ${type} but previously it was casted to ${object[TYPE_FIELD]}`);\n    }\n  }\n\n  return object as U & ForcedSubject<T>;\n}\n\nexport const isSubjectType = (value: unknown): value is SubjectType => {\n  const type = typeof value;\n  return type === 'string' || type === 'function';\n};\n\nconst getSubjectClassName = (value: SubjectClass) => value.modelName || value.name;\nexport const getSubjectTypeName = (value: SubjectType) => {\n  return typeof value === 'string' ? value : getSubjectClassName(value);\n};\n\nexport function detectSubjectType(subject: Exclude<Subject, SubjectType>): string {\n  if (subject.hasOwnProperty(TYPE_FIELD)) {\n    return (subject as any)[TYPE_FIELD];\n  }\n\n  return getSubjectClassName(subject.constructor as SubjectClass);\n}\n\ntype AliasMerge = (actions: string[], action: string | string[]) => string[];\nfunction expandActions(aliasMap: AliasesMap, rawActions: string | string[], merge: AliasMerge) {\n  let actions = wrapArray(rawActions);\n  let i = 0;\n\n  while (i < actions.length) {\n    const action = actions[i++];\n\n    if (aliasMap.hasOwnProperty(action)) {\n      actions = merge(actions, aliasMap[action]);\n    }\n  }\n\n  return actions;\n}\n\nfunction findDuplicate(actions: string[], actionToFind: string | string[]) {\n  if (typeof actionToFind === 'string' && actions.indexOf(actionToFind) !== -1) {\n    return actionToFind;\n  }\n\n  for (let i = 0; i < actionToFind.length; i++) {\n    if (actions.indexOf(actionToFind[i]) !== -1) return actionToFind[i];\n  }\n\n  return null;\n}\n\nconst defaultAliasMerge: AliasMerge = (actions, action) => actions.concat(action);\nfunction validateForCycles(aliasMap: AliasesMap, reservedAction: string) {\n  if (reservedAction in aliasMap) {\n    throw new Error(`Cannot use \"${reservedAction}\" as an alias because it's reserved action.`);\n  }\n\n  const keys = Object.keys(aliasMap);\n  const mergeAliasesAndDetectCycles: AliasMerge = (actions, action) => {\n    const duplicate = findDuplicate(actions, action);\n    if (duplicate) throw new Error(`Detected cycle ${duplicate} -> ${actions.join(', ')}`);\n\n    const isUsingReservedAction = typeof action === 'string' && action === reservedAction\n      || actions.indexOf(reservedAction) !== -1\n      || Array.isArray(action) && action.indexOf(reservedAction) !== -1;\n    if (isUsingReservedAction) throw new Error(`Cannot make an alias to \"${reservedAction}\" because this is reserved action`);\n\n    return actions.concat(action);\n  };\n\n  for (let i = 0; i < keys.length; i++) {\n    expandActions(aliasMap, keys[i], mergeAliasesAndDetectCycles);\n  }\n}\n\nexport type AliasResolverOptions = { skipValidate?: boolean; anyAction?: string };\nexport function createAliasResolver(aliasMap: AliasesMap, options?: AliasResolverOptions) {\n  if (!options || options.skipValidate !== false) {\n    validateForCycles(aliasMap, options && options.anyAction || 'manage');\n  }\n\n  return (action: string | string[]) => expandActions(aliasMap, action, defaultAliasMerge);\n}\n\nfunction copyArrayTo<T>(dest: T[], target: T[], start: number) {\n  for (let i = start; i < target.length; i++) {\n    dest.push(target[i]);\n  }\n}\n\nexport function mergePrioritized<T extends { priority: number }>(\n  array?: T[],\n  anotherArray?: T[]\n): T[] {\n  if (!array || !array.length) {\n    return anotherArray || [];\n  }\n\n  if (!anotherArray || !anotherArray.length) {\n    return array || [];\n  }\n\n  let i = 0;\n  let j = 0;\n  const merged: T[] = [];\n\n  while (i < array.length && j < anotherArray.length) {\n    if (array[i].priority < anotherArray[j].priority) {\n      merged.push(array[i]);\n      i++;\n    } else {\n      merged.push(anotherArray[j]);\n      j++;\n    }\n  }\n\n  copyArrayTo(merged, array, i);\n  copyArrayTo(merged, anotherArray, j);\n\n  return merged;\n}\n\nexport function getOrDefault<K, V>(map: Map<K, V>, key: K, defaultValue: () => V) {\n  let value = map.get(key);\n\n  if (!value) {\n    value = defaultValue();\n    map.set(key, value);\n  }\n\n  return value;\n}\n\nexport const identity = <T>(x: T) => x;\n","import { Condition, buildAnd, buildOr } from '@ucast/mongo2js';\nimport { PureAbility, AnyAbility } from './PureAbility';\nimport { RuleOf } from './RuleIndex';\nimport { RawRule } from './RawRule';\nimport { Rule } from './Rule';\nimport { setByPath, wrapArray } from './utils';\nimport { AnyObject, SubjectType, ExtractSubjectType } from './types';\n\nexport type RuleToQueryConverter<T extends AnyAbility> = (rule: RuleOf<T>) => object;\nexport interface AbilityQuery<T = object> {\n  $or?: T[]\n  $and?: T[]\n}\n\nexport function rulesToQuery<T extends AnyAbility>(\n  ability: T,\n  action: Parameters<T['rulesFor']>[0],\n  subjectType: ExtractSubjectType<Parameters<T['rulesFor']>[1]>,\n  convert: RuleToQueryConverter<T>\n): AbilityQuery | null {\n  const query: AbilityQuery = {};\n  const rules = ability.rulesFor(action, subjectType);\n\n  for (let i = 0; i < rules.length; i++) {\n    const rule = rules[i];\n    const op = rule.inverted ? '$and' : '$or';\n\n    if (!rule.conditions) {\n      if (rule.inverted) {\n        break;\n      } else {\n        delete query[op];\n        return query;\n      }\n    } else {\n      query[op] = query[op] || [];\n      query[op]!.push(convert(rule));\n    }\n  }\n\n  return query.$or ? query : null;\n}\n\nfunction ruleToAST(rule: RuleOf<AnyAbility>): Condition {\n  if (!rule.ast) {\n    throw new Error(`Ability rule \"${JSON.stringify(rule)}\" does not have \"ast\" property. So, cannot be used to generate AST`);\n  }\n  return rule.ast;\n}\n\nexport function rulesToAST<T extends AnyAbility>(\n  ability: T,\n  action: Parameters<T['rulesFor']>[0],\n  subjectType: ExtractSubjectType<Parameters<T['rulesFor']>[1]>,\n): Condition | null {\n  const query = rulesToQuery(ability, action, subjectType, ruleToAST) as AbilityQuery<Condition>;\n\n  if (query === null) {\n    return null;\n  }\n\n  if (!query.$and) {\n    return query.$or ? buildOr(query.$or) : buildAnd([]);\n  }\n\n  if (query.$or) {\n    query.$and.push(buildOr(query.$or));\n  }\n\n  return buildAnd(query.$and);\n}\n\nexport function rulesToFields<T extends PureAbility<any, AnyObject>>(\n  ability: T,\n  action: Parameters<T['rulesFor']>[0],\n  subjectType: ExtractSubjectType<Parameters<T['rulesFor']>[1]>,\n): AnyObject {\n  return ability.rulesFor(action, subjectType)\n    .reduce((values, rule) => {\n      if (rule.inverted || !rule.conditions) {\n        return values;\n      }\n\n      return Object.keys(rule.conditions).reduce((fields, fieldName) => {\n        const value = rule.conditions![fieldName];\n\n        if (!value || (value as any).constructor !== Object) {\n          setByPath(fields, fieldName, value);\n        }\n\n        return fields;\n      }, values);\n    }, {} as AnyObject);\n}\n\nexport type GetRuleFields<R extends Rule<any, any>> = (rule: R) => string[];\n\nexport interface PermittedFieldsOptions<T extends AnyAbility> {\n  fieldsFrom: GetRuleFields<RuleOf<T>>\n}\n\nexport function permittedFieldsOf<T extends AnyAbility>(\n  ability: T,\n  action: Parameters<T['can']>[0],\n  subject: Parameters<T['can']>[1],\n  options: PermittedFieldsOptions<T>\n): string[] {\n  const subjectType = ability.detectSubjectType(subject);\n  const rules = ability.possibleRulesFor(action, subjectType);\n  const uniqueFields = new Set<string>();\n  const deleteItem = uniqueFields.delete.bind(uniqueFields);\n  const addItem = uniqueFields.add.bind(uniqueFields);\n  let i = rules.length;\n\n  while (i--) {\n    const rule = rules[i];\n    if (rule.matchesConditions(subject)) {\n      const toggle = rule.inverted ? deleteItem : addItem;\n      options.fieldsFrom(rule).forEach(toggle);\n    }\n  }\n\n  return Array.from(uniqueFields);\n}\n\nconst joinIfArray = (value: string | string[]) => Array.isArray(value) ? value.join(',') : value;\n\nexport type PackRule<T extends RawRule<any, any>> =\n  [string, string] |\n  [string, string, T['conditions']] |\n  [string, string, T['conditions'] | 0, 1] |\n  [string, string, T['conditions'] | 0, 1 | 0, string] |\n  [string, string, T['conditions'] | 0, 1 | 0, string | 0, string];\n\nexport type PackSubjectType<T extends SubjectType> = (type: T) => string;\n\nexport function packRules<T extends RawRule<any, any>>(\n  rules: T[],\n  packSubject?: PackSubjectType<T['subject']>\n): PackRule<T>[] {\n  return rules.map((rule) => { // eslint-disable-line\n    const packedRule: PackRule<T> = [\n      joinIfArray((rule as any).action || (rule as any).actions),\n      typeof packSubject === 'function'\n        ? wrapArray(rule.subject).map(packSubject).join(',')\n        : joinIfArray(rule.subject),\n      rule.conditions || 0,\n      rule.inverted ? 1 : 0,\n      rule.fields ? joinIfArray(rule.fields) : 0,\n      rule.reason || ''\n    ];\n\n    while (!packedRule[packedRule.length - 1]) packedRule.pop();\n\n    return packedRule;\n  });\n}\n\nexport type UnpackSubjectType<T extends SubjectType> = (type: string) => T;\n\nexport function unpackRules<T extends RawRule<any, any>>(\n  rules: PackRule<T>[],\n  unpackSubject?: UnpackSubjectType<T['subject']>\n): T[] {\n  return rules.map(([action, subject, conditions, inverted, fields, reason]) => {\n    const subjects = subject.split(',');\n    const rule = {\n      inverted: !!inverted,\n      action: action.split(','),\n      subject: typeof unpackSubject === 'function'\n        ? subjects.map(unpackSubject)\n        : subjects\n    } as T;\n\n    if (conditions) {\n      rule.conditions = conditions;\n    }\n\n    if (fields) {\n      rule.fields = fields.split(',');\n    }\n\n    if (reason) {\n      rule.reason = reason;\n    }\n\n    return rule;\n  });\n}\n"],"names":["wrapArray","value","Array","isArray","setByPath","object","path","ref","lastKey","indexOf","keys","split","pop","reduce","res","prop","rulesToQuery","ability","action","subjectType","convert","query","rules","rulesFor","i","length","rule","op","inverted","conditions","push","$or","ruleToAST","ast","Error","JSON","stringify","rulesToAST","$and","buildOr","buildAnd","rulesToFields","values","Object","fields","fieldName","constructor","permittedFieldsOf","subject","options","detectSubjectType","possibleRulesFor","uniqueFields","Set","deleteItem","delete","bind","addItem","add","matchesConditions","toggle","fieldsFrom","forEach","from","joinIfArray","join","packRules","packSubject","map","packedRule","actions","reason","unpackRules","unpackSubject","subjects"],"mappings":"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"}