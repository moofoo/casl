{"version":3,"file":"extra.js","sources":["../../src/utils.ts","../../src/extra.ts"],"sourcesContent":["import { AnyObject, Subject, SubjectType, SubjectClass, ForcedSubject, AliasesMap } from './types';\n\nexport function wrapArray<T>(value: T[] | T): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n\nexport function setByPath(object: AnyObject, path: string, value: unknown): void {\n  let ref = object;\n  let lastKey = path;\n\n  if (path.indexOf('.') !== -1) {\n    const keys = path.split('.');\n\n    lastKey = keys.pop()!;\n    ref = keys.reduce((res, prop) => {\n      res[prop] = res[prop] || {};\n      return res[prop] as AnyObject;\n    }, object);\n  }\n\n  ref[lastKey] = value;\n}\n\nconst TYPE_FIELD = '__caslSubjectType__';\nexport function setSubjectType<\n  T extends string,\n  U extends Record<PropertyKey, any>\n>(type: T, object: U): U & ForcedSubject<T> {\n  if (object) {\n    if (!object.hasOwnProperty(TYPE_FIELD)) {\n      Object.defineProperty(object, TYPE_FIELD, { value: type });\n    } else if (type !== object[TYPE_FIELD]) {\n      throw new Error(`Trying to cast object to subject type ${type} but previously it was casted to ${object[TYPE_FIELD]}`);\n    }\n  }\n\n  return object as U & ForcedSubject<T>;\n}\n\nexport const isSubjectType = (value: unknown): value is SubjectType => {\n  const type = typeof value;\n  return type === 'string' || type === 'function';\n};\n\nconst getSubjectClassName = (value: SubjectClass) => value.modelName || value.name;\nexport const getSubjectTypeName = (value: SubjectType) => {\n  return typeof value === 'string' ? value : getSubjectClassName(value);\n};\n\nexport function detectSubjectType(subject: Exclude<Subject, SubjectType>): string {\n  if (subject.hasOwnProperty(TYPE_FIELD)) {\n    return (subject as any)[TYPE_FIELD];\n  }\n\n  return getSubjectClassName(subject.constructor as SubjectClass);\n}\n\ntype AliasMerge = (actions: string[], action: string | string[]) => string[];\nfunction expandActions(aliasMap: AliasesMap, rawActions: string | string[], merge: AliasMerge) {\n  let actions = wrapArray(rawActions);\n  let i = 0;\n\n  while (i < actions.length) {\n    const action = actions[i++];\n\n    if (aliasMap.hasOwnProperty(action)) {\n      actions = merge(actions, aliasMap[action]);\n    }\n  }\n\n  return actions;\n}\n\nfunction findDuplicate(actions: string[], actionToFind: string | string[]) {\n  if (typeof actionToFind === 'string' && actions.indexOf(actionToFind) !== -1) {\n    return actionToFind;\n  }\n\n  for (let i = 0; i < actionToFind.length; i++) {\n    if (actions.indexOf(actionToFind[i]) !== -1) return actionToFind[i];\n  }\n\n  return null;\n}\n\nconst defaultAliasMerge: AliasMerge = (actions, action) => actions.concat(action);\nfunction validateForCycles(aliasMap: AliasesMap, reservedAction: string) {\n  if (reservedAction in aliasMap) {\n    throw new Error(`Cannot use \"${reservedAction}\" as an alias because it's reserved action.`);\n  }\n\n  const keys = Object.keys(aliasMap);\n  const mergeAliasesAndDetectCycles: AliasMerge = (actions, action) => {\n    const duplicate = findDuplicate(actions, action);\n    if (duplicate) throw new Error(`Detected cycle ${duplicate} -> ${actions.join(', ')}`);\n\n    const isUsingReservedAction = typeof action === 'string' && action === reservedAction\n      || actions.indexOf(reservedAction) !== -1\n      || Array.isArray(action) && action.indexOf(reservedAction) !== -1;\n    if (isUsingReservedAction) throw new Error(`Cannot make an alias to \"${reservedAction}\" because this is reserved action`);\n\n    return actions.concat(action);\n  };\n\n  for (let i = 0; i < keys.length; i++) {\n    expandActions(aliasMap, keys[i], mergeAliasesAndDetectCycles);\n  }\n}\n\nexport type AliasResolverOptions = { skipValidate?: boolean; anyAction?: string };\nexport function createAliasResolver(aliasMap: AliasesMap, options?: AliasResolverOptions) {\n  if (!options || options.skipValidate !== false) {\n    validateForCycles(aliasMap, options && options.anyAction || 'manage');\n  }\n\n  return (action: string | string[]) => expandActions(aliasMap, action, defaultAliasMerge);\n}\n\nfunction copyArrayTo<T>(dest: T[], target: T[], start: number) {\n  for (let i = start; i < target.length; i++) {\n    dest.push(target[i]);\n  }\n}\n\nexport function mergePrioritized<T extends { priority: number }>(\n  array?: T[],\n  anotherArray?: T[]\n): T[] {\n  if (!array || !array.length) {\n    return anotherArray || [];\n  }\n\n  if (!anotherArray || !anotherArray.length) {\n    return array || [];\n  }\n\n  let i = 0;\n  let j = 0;\n  const merged: T[] = [];\n\n  while (i < array.length && j < anotherArray.length) {\n    if (array[i].priority < anotherArray[j].priority) {\n      merged.push(array[i]);\n      i++;\n    } else {\n      merged.push(anotherArray[j]);\n      j++;\n    }\n  }\n\n  copyArrayTo(merged, array, i);\n  copyArrayTo(merged, anotherArray, j);\n\n  return merged;\n}\n\nexport function getOrDefault<K, V>(map: Map<K, V>, key: K, defaultValue: () => V) {\n  let value = map.get(key);\n\n  if (!value) {\n    value = defaultValue();\n    map.set(key, value);\n  }\n\n  return value;\n}\n\nexport const identity = <T>(x: T) => x;\n","import { Condition, buildAnd, buildOr } from '@ucast/mongo2js';\nimport { PureAbility, AnyAbility } from './PureAbility';\nimport { RuleOf } from './RuleIndex';\nimport { RawRule } from './RawRule';\nimport { Rule } from './Rule';\nimport { setByPath, wrapArray } from './utils';\nimport { AnyObject, SubjectType, ExtractSubjectType } from './types';\n\nexport type RuleToQueryConverter<T extends AnyAbility> = (rule: RuleOf<T>) => object;\nexport interface AbilityQuery<T = object> {\n  $or?: T[]\n  $and?: T[]\n}\n\nexport function rulesToQuery<T extends AnyAbility>(\n  ability: T,\n  action: Parameters<T['rulesFor']>[0],\n  subjectType: ExtractSubjectType<Parameters<T['rulesFor']>[1]>,\n  convert: RuleToQueryConverter<T>\n): AbilityQuery | null {\n  const query: AbilityQuery = {};\n  const rules = ability.rulesFor(action, subjectType);\n\n  for (let i = 0; i < rules.length; i++) {\n    const rule = rules[i];\n    const op = rule.inverted ? '$and' : '$or';\n\n    if (!rule.conditions) {\n      if (rule.inverted) {\n        break;\n      } else {\n        delete query[op];\n        return query;\n      }\n    } else {\n      query[op] = query[op] || [];\n      query[op]!.push(convert(rule));\n    }\n  }\n\n  return query.$or ? query : null;\n}\n\nfunction ruleToAST(rule: RuleOf<AnyAbility>): Condition {\n  if (!rule.ast) {\n    throw new Error(`Ability rule \"${JSON.stringify(rule)}\" does not have \"ast\" property. So, cannot be used to generate AST`);\n  }\n  return rule.ast;\n}\n\nexport function rulesToAST<T extends AnyAbility>(\n  ability: T,\n  action: Parameters<T['rulesFor']>[0],\n  subjectType: ExtractSubjectType<Parameters<T['rulesFor']>[1]>,\n): Condition | null {\n  const query = rulesToQuery(ability, action, subjectType, ruleToAST) as AbilityQuery<Condition>;\n\n  if (query === null) {\n    return null;\n  }\n\n  if (!query.$and) {\n    return query.$or ? buildOr(query.$or) : buildAnd([]);\n  }\n\n  if (query.$or) {\n    query.$and.push(buildOr(query.$or));\n  }\n\n  return buildAnd(query.$and);\n}\n\nexport function rulesToFields<T extends PureAbility<any, AnyObject>>(\n  ability: T,\n  action: Parameters<T['rulesFor']>[0],\n  subjectType: ExtractSubjectType<Parameters<T['rulesFor']>[1]>,\n): AnyObject {\n  return ability.rulesFor(action, subjectType)\n    .reduce((values, rule) => {\n      if (rule.inverted || !rule.conditions) {\n        return values;\n      }\n\n      return Object.keys(rule.conditions).reduce((fields, fieldName) => {\n        const value = rule.conditions![fieldName];\n\n        if (!value || (value as any).constructor !== Object) {\n          setByPath(fields, fieldName, value);\n        }\n\n        return fields;\n      }, values);\n    }, {} as AnyObject);\n}\n\nexport type GetRuleFields<R extends Rule<any, any>> = (rule: R) => string[];\n\nexport interface PermittedFieldsOptions<T extends AnyAbility> {\n  fieldsFrom: GetRuleFields<RuleOf<T>>\n}\n\nexport function permittedFieldsOf<T extends AnyAbility>(\n  ability: T,\n  action: Parameters<T['can']>[0],\n  subject: Parameters<T['can']>[1],\n  options: PermittedFieldsOptions<T>\n): string[] {\n  const subjectType = ability.detectSubjectType(subject);\n  const rules = ability.possibleRulesFor(action, subjectType);\n  const uniqueFields = new Set<string>();\n  const deleteItem = uniqueFields.delete.bind(uniqueFields);\n  const addItem = uniqueFields.add.bind(uniqueFields);\n  let i = rules.length;\n\n  while (i--) {\n    const rule = rules[i];\n    if (rule.matchesConditions(subject)) {\n      const toggle = rule.inverted ? deleteItem : addItem;\n      options.fieldsFrom(rule).forEach(toggle);\n    }\n  }\n\n  return Array.from(uniqueFields);\n}\n\nconst joinIfArray = (value: string | string[]) => Array.isArray(value) ? value.join(',') : value;\n\nexport type PackRule<T extends RawRule<any, any>> =\n  [string, string] |\n  [string, string, T['conditions']] |\n  [string, string, T['conditions'] | 0, 1] |\n  [string, string, T['conditions'] | 0, 1 | 0, string] |\n  [string, string, T['conditions'] | 0, 1 | 0, string | 0, string];\n\nexport type PackSubjectType<T extends SubjectType> = (type: T) => string;\n\nexport function packRules<T extends RawRule<any, any>>(\n  rules: T[],\n  packSubject?: PackSubjectType<T['subject']>\n): PackRule<T>[] {\n  return rules.map((rule) => { // eslint-disable-line\n    const packedRule: PackRule<T> = [\n      joinIfArray((rule as any).action || (rule as any).actions),\n      typeof packSubject === 'function'\n        ? wrapArray(rule.subject).map(packSubject).join(',')\n        : joinIfArray(rule.subject),\n      rule.conditions || 0,\n      rule.inverted ? 1 : 0,\n      rule.fields ? joinIfArray(rule.fields) : 0,\n      rule.reason || ''\n    ];\n\n    while (!packedRule[packedRule.length - 1]) packedRule.pop();\n\n    return packedRule;\n  });\n}\n\nexport type UnpackSubjectType<T extends SubjectType> = (type: string) => T;\n\nexport function unpackRules<T extends RawRule<any, any>>(\n  rules: PackRule<T>[],\n  unpackSubject?: UnpackSubjectType<T['subject']>\n): T[] {\n  return rules.map(([action, subject, conditions, inverted, fields, reason]) => {\n    const subjects = subject.split(',');\n    const rule = {\n      inverted: !!inverted,\n      action: action.split(','),\n      subject: typeof unpackSubject === 'function'\n        ? subjects.map(unpackSubject)\n        : subjects\n    } as T;\n\n    if (conditions) {\n      rule.conditions = conditions;\n    }\n\n    if (fields) {\n      rule.fields = fields.split(',');\n    }\n\n    if (reason) {\n      rule.reason = reason;\n    }\n\n    return rule;\n  });\n}\n"],"names":["wrapArray","value","Array","isArray","setByPath","object","path","ref","lastKey","indexOf","keys","split","pop","reduce","res","prop","rulesToQuery","ability","action","subjectType","convert","query","rules","rulesFor","i","length","rule","op","inverted","conditions","push","$or","ruleToAST","ast","Error","JSON","stringify","rulesToAST","$and","buildOr","buildAnd","rulesToFields","values","Object","fields","fieldName","constructor","permittedFieldsOf","subject","options","detectSubjectType","possibleRulesFor","uniqueFields","Set","deleteItem","delete","bind","addItem","add","matchesConditions","toggle","fieldsFrom","forEach","from","joinIfArray","join","packRules","packSubject","map","packedRule","actions","reason","unpackRules","unpackSubject","subjects"],"mappings":"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"}