{"version":3,"file":"index.js","sources":["../../src/utils.ts","../../src/Rule.ts","../../src/structures/LinkedItem.ts","../../src/RuleIndex.ts","../../src/PureAbility.ts","../../src/matchers/conditions.ts","../../src/matchers/field.ts","../../src/Ability.ts","../../src/AbilityBuilder.ts","../../src/ForbiddenError.ts"],"sourcesContent":["import { AnyObject, Subject, SubjectType, SubjectClass, ForcedSubject, AliasesMap } from './types';\n\nexport function wrapArray<T>(value: T[] | T): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n\nexport function setByPath(object: AnyObject, path: string, value: unknown): void {\n  let ref = object;\n  let lastKey = path;\n\n  if (path.indexOf('.') !== -1) {\n    const keys = path.split('.');\n\n    lastKey = keys.pop()!;\n    ref = keys.reduce((res, prop) => {\n      res[prop] = res[prop] || {};\n      return res[prop] as AnyObject;\n    }, object);\n  }\n\n  ref[lastKey] = value;\n}\n\nconst TYPE_FIELD = '__caslSubjectType__';\nexport function setSubjectType<\n  T extends string,\n  U extends Record<PropertyKey, any>\n>(type: T, object: U): U & ForcedSubject<T> {\n  if (object) {\n    if (!object.hasOwnProperty(TYPE_FIELD)) {\n      Object.defineProperty(object, TYPE_FIELD, { value: type });\n    } else if (type !== object[TYPE_FIELD]) {\n      throw new Error(`Trying to cast object to subject type ${type} but previously it was casted to ${object[TYPE_FIELD]}`);\n    }\n  }\n\n  return object as U & ForcedSubject<T>;\n}\n\nexport const isSubjectType = (value: unknown): value is SubjectType => {\n  const type = typeof value;\n  return type === 'string' || type === 'function';\n};\n\nconst getSubjectClassName = (value: SubjectClass) => value.modelName || value.name;\nexport const getSubjectTypeName = (value: SubjectType) => {\n  return typeof value === 'string' ? value : getSubjectClassName(value);\n};\n\nexport function detectSubjectType(subject: Exclude<Subject, SubjectType>): string {\n  if (subject.hasOwnProperty(TYPE_FIELD)) {\n    return (subject as any)[TYPE_FIELD];\n  }\n\n  return getSubjectClassName(subject.constructor as SubjectClass);\n}\n\ntype AliasMerge = (actions: string[], action: string | string[]) => string[];\nfunction expandActions(aliasMap: AliasesMap, rawActions: string | string[], merge: AliasMerge) {\n  let actions = wrapArray(rawActions);\n  let i = 0;\n\n  while (i < actions.length) {\n    const action = actions[i++];\n\n    if (aliasMap.hasOwnProperty(action)) {\n      actions = merge(actions, aliasMap[action]);\n    }\n  }\n\n  return actions;\n}\n\nfunction findDuplicate(actions: string[], actionToFind: string | string[]) {\n  if (typeof actionToFind === 'string' && actions.indexOf(actionToFind) !== -1) {\n    return actionToFind;\n  }\n\n  for (let i = 0; i < actionToFind.length; i++) {\n    if (actions.indexOf(actionToFind[i]) !== -1) return actionToFind[i];\n  }\n\n  return null;\n}\n\nconst defaultAliasMerge: AliasMerge = (actions, action) => actions.concat(action);\nfunction validateForCycles(aliasMap: AliasesMap, reservedAction: string) {\n  if (reservedAction in aliasMap) {\n    throw new Error(`Cannot use \"${reservedAction}\" as an alias because it's reserved action.`);\n  }\n\n  const keys = Object.keys(aliasMap);\n  const mergeAliasesAndDetectCycles: AliasMerge = (actions, action) => {\n    const duplicate = findDuplicate(actions, action);\n    if (duplicate) throw new Error(`Detected cycle ${duplicate} -> ${actions.join(', ')}`);\n\n    const isUsingReservedAction = typeof action === 'string' && action === reservedAction\n      || actions.indexOf(reservedAction) !== -1\n      || Array.isArray(action) && action.indexOf(reservedAction) !== -1;\n    if (isUsingReservedAction) throw new Error(`Cannot make an alias to \"${reservedAction}\" because this is reserved action`);\n\n    return actions.concat(action);\n  };\n\n  for (let i = 0; i < keys.length; i++) {\n    expandActions(aliasMap, keys[i], mergeAliasesAndDetectCycles);\n  }\n}\n\nexport type AliasResolverOptions = { skipValidate?: boolean; anyAction?: string };\nexport function createAliasResolver(aliasMap: AliasesMap, options?: AliasResolverOptions) {\n  if (!options || options.skipValidate !== false) {\n    validateForCycles(aliasMap, options && options.anyAction || 'manage');\n  }\n\n  return (action: string | string[]) => expandActions(aliasMap, action, defaultAliasMerge);\n}\n\nfunction copyArrayTo<T>(dest: T[], target: T[], start: number) {\n  for (let i = start; i < target.length; i++) {\n    dest.push(target[i]);\n  }\n}\n\nexport function mergePrioritized<T extends { priority: number }>(\n  array?: T[],\n  anotherArray?: T[]\n): T[] {\n  if (!array || !array.length) {\n    return anotherArray || [];\n  }\n\n  if (!anotherArray || !anotherArray.length) {\n    return array || [];\n  }\n\n  let i = 0;\n  let j = 0;\n  const merged: T[] = [];\n\n  while (i < array.length && j < anotherArray.length) {\n    if (array[i].priority < anotherArray[j].priority) {\n      merged.push(array[i]);\n      i++;\n    } else {\n      merged.push(anotherArray[j]);\n      j++;\n    }\n  }\n\n  copyArrayTo(merged, array, i);\n  copyArrayTo(merged, anotherArray, j);\n\n  return merged;\n}\n\nexport function getOrDefault<K, V>(map: Map<K, V>, key: K, defaultValue: () => V) {\n  let value = map.get(key);\n\n  if (!value) {\n    value = defaultValue();\n    map.set(key, value);\n  }\n\n  return value;\n}\n\nexport const identity = <T>(x: T) => x;\n","import { wrapArray, isSubjectType } from './utils';\nimport {\n  MatchConditions,\n  MatchField,\n  Abilities,\n  ToAbilityTypes,\n  Normalize,\n  ConditionsMatcher,\n  FieldMatcher,\n} from './types';\nimport { RawRule, RawRuleFrom } from './RawRule';\n\ntype Tuple<A extends Abilities> = Normalize<ToAbilityTypes<A>>;\n\nfunction validate(rule: RawRuleFrom<Abilities, any>, options: RuleOptions<any>) {\n  if (Array.isArray(rule.fields) && !rule.fields.length) {\n    throw new Error('`rawRule.fields` cannot be an empty array. https://bit.ly/390miLa');\n  }\n\n  if (rule.fields && !options.fieldMatcher) {\n    throw new Error('You need to pass \"fieldMatcher\" option in order to restrict access by fields');\n  }\n\n  if (rule.conditions && !options.conditionsMatcher) {\n    throw new Error('You need to pass \"conditionsMatcher\" option in order to restrict access by conditions');\n  }\n}\n\nexport interface RuleOptions<Conditions> {\n  conditionsMatcher?: ConditionsMatcher<Conditions>\n  fieldMatcher?: FieldMatcher\n  resolveAction(action: string | string[]): string | string[]\n}\n\nexport class Rule<A extends Abilities, C> {\n  private _matchConditions: MatchConditions | undefined;\n  private _matchField: MatchField<string> | undefined;\n  private readonly _options!: RuleOptions<C>;\n  public readonly action!: Tuple<A>[0] | Tuple<A>[0][];\n  public readonly subject!: Tuple<A>[1] | Tuple<A>[1][];\n  public readonly inverted!: boolean;\n  public readonly conditions!: C | undefined;\n  public readonly fields!: string[] | undefined;\n  public readonly reason!: string | undefined;\n  public readonly priority!: number;\n\n  constructor(\n    rule: RawRule<ToAbilityTypes<A>, C>,\n    options: RuleOptions<C>,\n    priority: number = 0\n  ) {\n    validate(rule, options);\n\n    this.action = options.resolveAction(rule.action);\n    this.subject = rule.subject!;\n    this.inverted = !!rule.inverted;\n    this.conditions = rule.conditions;\n    this.reason = rule.reason;\n    this.fields = rule.fields ? wrapArray(rule.fields) : undefined;\n    this.priority = priority;\n    this._options = options;\n  }\n\n  private _conditionsMatcher() {\n    if (this.conditions && !this._matchConditions) {\n      this._matchConditions = this._options.conditionsMatcher!(this.conditions);\n    }\n\n    return this._matchConditions!;\n  }\n\n  get ast() {\n    const matches = this._conditionsMatcher();\n    return matches ? matches.ast : undefined;\n  }\n\n  matchesConditions(object: Normalize<A>[1] | undefined): boolean {\n    if (!this.conditions) {\n      return true;\n    }\n\n    if (!object || isSubjectType(object)) {\n      return !this.inverted;\n    }\n\n    const matches = this._conditionsMatcher();\n    return matches(object as Record<string, unknown>);\n  }\n\n  matchesField(field: string | undefined): boolean {\n    if (!this.fields) {\n      return true;\n    }\n\n    if (!field) {\n      return !this.inverted;\n    }\n\n    if (this.fields && !this._matchField) {\n      this._matchField = this._options.fieldMatcher!(this.fields);\n    }\n\n    return this._matchField!(field);\n  }\n}\n","export interface LinkedItem<T> {\n  next: LinkedItem<T> | null\n  prev: LinkedItem<T> | null\n  readonly value: T\n}\n\nexport function linkedItem<T>(value: T, prev: LinkedItem<T>['prev']) {\n  const item = { value, prev, next: null };\n\n  if (prev) {\n    prev.next = item;\n  }\n\n  return item;\n}\n\nexport function unlinkItem(item: LinkedItem<any>) {\n  if (item.next) {\n    item.next.prev = item.prev;\n  }\n\n  if (item.prev) {\n    item.prev.next = item.next;\n  }\n\n  item.next = item.prev = null; // eslint-disable-line\n}\n\nexport const cloneLinkedItem = <T extends LinkedItem<any>>(item: T): T => ({\n  value: item.value,\n  prev: item.prev,\n  next: item.next,\n} as T);\n","import { Rule, RuleOptions } from './Rule';\nimport { RawRuleFrom } from './RawRule';\nimport {\n  Abilities,\n  Normalize,\n  SubjectType,\n  AbilityParameters,\n  AbilityTuple,\n  ExtractSubjectType\n} from './types';\nimport { wrapArray, detectSubjectType, mergePrioritized, getOrDefault, identity, isSubjectType } from './utils';\nimport { LinkedItem, linkedItem, unlinkItem, cloneLinkedItem } from './structures/LinkedItem';\n\nexport interface RuleIndexOptions<A extends Abilities, C> extends Partial<RuleOptions<C>> {\n  detectSubjectType?(\n    subject: Exclude<Normalize<A>[1], SubjectType>\n  ): ExtractSubjectType<Normalize<A>[1]>;\n  anyAction?: string;\n  anySubjectType?: string;\n}\n\ndeclare const $abilities: unique symbol;\ndeclare const $conditions: unique symbol;\ninterface WithGenerics {\n  [$abilities]: any\n  [$conditions]: any\n}\nexport type Public<T extends WithGenerics> = { [K in keyof T]: T[K] };\nexport interface Generics<T extends WithGenerics> {\n  abilities: T[typeof $abilities],\n  conditions: T[typeof $conditions]\n}\n\nexport type RuleOf<T extends WithGenerics> =\n  Rule<Generics<T>['abilities'], Generics<T>['conditions']>;\nexport type RawRuleOf<T extends WithGenerics> =\n  RawRuleFrom<Generics<T>['abilities'], Generics<T>['conditions']>;\n\nexport type RuleIndexOptionsOf<T extends WithGenerics> =\n  RuleIndexOptions<Generics<T>['abilities'], Generics<T>['conditions']>;\n\ninterface AbilityEvent<T extends WithGenerics> {\n  target: T\n  /** @deprecated use \"target\" property instead */\n  ability: T\n}\n\nexport interface UpdateEvent<T extends WithGenerics> extends AbilityEvent<T> {\n  rules: RawRuleOf<T>[]\n}\n/**\n * @deprecated `on`/`emit` properly infer type without this type\n * TODO(major): delete\n */\nexport type EventHandler<Event> = (event: Event) => void;\n\nexport type Events<\n  T extends WithGenerics,\n  K extends keyof EventsMap<T> = keyof EventsMap<T>\n> = Map<K, LinkedItem<EventsMap<T>[K]> | null>;\n\ninterface EventsMap<T extends WithGenerics> {\n  update(event: UpdateEvent<T>): void\n  updated(event: UpdateEvent<T>): void\n}\n\ntype IndexTree<A extends Abilities, C> = Map<SubjectType, Map<string, {\n  rules: Rule<A, C>[],\n  merged: boolean\n}>>;\n\nexport type Unsubscribe = () => void;\n\nconst defaultActionEntry = () => ({\n  rules: [] as unknown as Rule<any, any>[],\n  merged: false\n});\nconst defaultSubjectEntry = () => new Map<string, ReturnType<typeof defaultActionEntry>>();\nconst analyze = (index: any, rule: Rule<any, any>) => {\n  if (!index._hasPerFieldRules && rule.fields) {\n    index._hasPerFieldRules = true;\n  }\n};\n\ntype AbilitySubjectTypeParameters<T extends Abilities, IncludeField extends boolean = true> =\n  AbilityParameters<\n  T,\n  T extends AbilityTuple\n    ? IncludeField extends true\n      ? (action: T[0], subject: ExtractSubjectType<T[1]>, field?: string) => 0\n      : (action: T[0], subject: ExtractSubjectType<T[1]>) => 0\n    : never,\n  (action: Extract<T, string>) => 0\n  >;\n\nexport class RuleIndex<A extends Abilities, Conditions> {\n  private _hasPerFieldRules: boolean = false;\n  private _events: Events<this> = new Map();\n  private _indexedRules!: IndexTree<A, Conditions>;\n  private _rules!: RawRuleFrom<A, Conditions>[];\n  private readonly _ruleOptions!: RuleOptions<Conditions>;\n  private readonly _detectSubjectType!: Required<RuleIndexOptions<A, Conditions>>['detectSubjectType'];\n  private readonly _anyAction: string;\n  private readonly _anySubjectType: string;\n  readonly [$abilities]!: A;\n  readonly [$conditions]!: Conditions;\n\n  constructor(\n    rules: RawRuleFrom<A, Conditions>[] = [],\n    options: RuleIndexOptions<A, Conditions> = {}\n  ) {\n    this._ruleOptions = {\n      conditionsMatcher: options.conditionsMatcher,\n      fieldMatcher: options.fieldMatcher,\n      resolveAction: options.resolveAction || identity,\n    };\n    this._anyAction = options.anyAction || 'manage';\n    this._anySubjectType = options.anySubjectType || 'all';\n    this._detectSubjectType = options.detectSubjectType || detectSubjectType;\n    this._rules = rules;\n    this._indexedRules = this._buildIndexFor(rules);\n  }\n\n  get rules() {\n    return this._rules;\n  }\n\n  detectSubjectType(object?: Normalize<A>[1]): ExtractSubjectType<Normalize<A>[1]> {\n    if (isSubjectType(object)) return object;\n    if (!object) return this._anySubjectType;\n    return this._detectSubjectType(object as Exclude<Normalize<A>[1], SubjectType>);\n  }\n\n  update(rules: RawRuleFrom<A, Conditions>[]): Public<this> {\n    const event = {\n      rules,\n      ability: this,\n      target: this\n    } as unknown as UpdateEvent<this>;\n\n    this._emit('update', event);\n    this._rules = rules;\n    this._indexedRules = this._buildIndexFor(rules);\n    this._emit('updated', event);\n\n    return this;\n  }\n\n  private _buildIndexFor(rawRules: RawRuleFrom<A, Conditions>[]) {\n    const indexedRules: IndexTree<A, Conditions> = new Map();\n\n    for (let i = rawRules.length - 1; i >= 0; i--) {\n      const priority = rawRules.length - i - 1;\n      const rule = new Rule(rawRules[i], this._ruleOptions, priority);\n      const actions = wrapArray(rule.action);\n      const subjects = wrapArray(rule.subject || this._anySubjectType);\n      analyze(this, rule);\n\n      for (let k = 0; k < subjects.length; k++) {\n        const subjectRules = getOrDefault(indexedRules, subjects[k], defaultSubjectEntry);\n\n        for (let j = 0; j < actions.length; j++) {\n          getOrDefault(subjectRules, actions[j], defaultActionEntry).rules.push(rule);\n        }\n      }\n    }\n\n    return indexedRules;\n  }\n\n  possibleRulesFor(...args: AbilitySubjectTypeParameters<A, false>): Rule<A, Conditions>[]\n  possibleRulesFor(\n    action: string,\n    subjectType: SubjectType = this._anySubjectType\n  ): Rule<A, Conditions>[] {\n    if (!isSubjectType(subjectType)) {\n      throw new Error('\"possibleRulesFor\" accepts only subject types (i.e., string or class) as the 2nd parameter');\n    }\n\n    const subjectRules = getOrDefault(this._indexedRules, subjectType, defaultSubjectEntry);\n    const actionRules = getOrDefault(subjectRules, action, defaultActionEntry);\n\n    if (actionRules.merged) {\n      return actionRules.rules;\n    }\n\n    const anyActionRules = action !== this._anyAction && subjectRules.has(this._anyAction)\n      ? subjectRules.get(this._anyAction)!.rules\n      : undefined;\n    let rules = mergePrioritized(actionRules.rules, anyActionRules);\n\n    if (subjectType !== this._anySubjectType) {\n      rules = mergePrioritized(rules, (this as any).possibleRulesFor(action, this._anySubjectType));\n    }\n\n    actionRules.rules = rules;\n    actionRules.merged = true;\n\n    return rules;\n  }\n\n  rulesFor(...args: AbilitySubjectTypeParameters<A>): Rule<A, Conditions>[]\n  rulesFor(action: string, subjectType?: SubjectType, field?: string): Rule<A, Conditions>[] {\n    const rules: Rule<A, Conditions>[] = (this as any).possibleRulesFor(action, subjectType);\n\n    if (field && typeof field !== 'string') {\n      throw new Error('The 3rd, `field` parameter is expected to be a string. See https://stalniy.github.io/casl/en/api/casl-ability#can-of-pure-ability for details');\n    }\n\n    if (!this._hasPerFieldRules) {\n      return rules;\n    }\n\n    return rules.filter(rule => rule.matchesField(field));\n  }\n\n  on<T extends keyof EventsMap<this>>(\n    event: T,\n    handler: EventsMap<Public<this>>[T]\n  ): Unsubscribe {\n    const tail = this._events.get(event) || null;\n    const item = linkedItem(handler, tail);\n    this._events.set(event, item);\n\n    return () => {\n      const currentTail = this._events.get(event);\n\n      if (!item.next && !item.prev && currentTail === item) {\n        this._events.delete(event);\n      } else if (item === currentTail) {\n        this._events.set(event, item.prev);\n      }\n\n      unlinkItem(item);\n    };\n  }\n\n  private _emit<T extends keyof EventsMap<this>>(\n    name: T,\n    payload: Parameters<EventsMap<this>[T]>[0]\n  ) {\n    let current = this._events.get(name) || null;\n    while (current !== null) {\n      const prev = current.prev ? cloneLinkedItem(current.prev) : null;\n      current.value(payload);\n      current = prev;\n    }\n  }\n}\n","import { RuleIndex, RuleIndexOptions, RuleIndexOptionsOf, Public, RawRuleOf } from './RuleIndex';\nimport { Abilities, AbilityTuple, CanParameters, Subject } from './types';\nimport { Rule } from './Rule';\n\nexport interface AbilityOptions<A extends Abilities, Conditions>\n  extends RuleIndexOptions<A, Conditions> {}\nexport interface AnyAbility extends Public<PureAbility<any, any>> {}\nexport interface AbilityOptionsOf<T extends AnyAbility> extends RuleIndexOptionsOf<T> {}\nexport type AbilityClass<T extends AnyAbility> = new (\n  rules?: RawRuleOf<T>[],\n  options?: AbilityOptionsOf<T>\n) => T;\n\nexport class PureAbility<\n  A extends Abilities = AbilityTuple,\n  Conditions = unknown\n> extends RuleIndex<A, Conditions> {\n  can(...args: CanParameters<A>): boolean {\n    const rule = this.relevantRuleFor(...args);\n    return !!rule && !rule.inverted;\n  }\n\n  relevantRuleFor(...args: CanParameters<A>): Rule<A, Conditions> | null\n  relevantRuleFor(action: string, subject?: Subject, field?: string): Rule<A, Conditions> | null {\n    const subjectType = this.detectSubjectType(subject);\n    const rules = (this as any).rulesFor(action, subjectType, field);\n\n    for (let i = 0, length = rules.length; i < length; i++) {\n      if (rules[i].matchesConditions(subject)) {\n        return rules[i];\n      }\n    }\n\n    return null;\n  }\n\n  cannot(...args: CanParameters<A>): boolean {\n    return !this.can(...args);\n  }\n}\n","import {\n  $eq,\n  eq,\n  $ne,\n  ne,\n  $lt,\n  lt,\n  $lte,\n  lte,\n  $gt,\n  gt,\n  $gte,\n  gte,\n  $in,\n  within,\n  $nin,\n  nin,\n  $all,\n  all,\n  $size,\n  size,\n  $regex,\n  $options,\n  regex,\n  $elemMatch,\n  elemMatch,\n  $exists,\n  exists,\n  and,\n  createFactory,\n  BuildMongoQuery,\n  DefaultOperators,\n} from '@ucast/mongo2js';\nimport { ConditionsMatcher, AnyObject } from '../types';\nimport { Container, GenericFactory } from '../hkt';\n\nconst defaultInstructions = {\n  $eq,\n  $ne,\n  $lt,\n  $lte,\n  $gt,\n  $gte,\n  $in,\n  $nin,\n  $all,\n  $size,\n  $regex,\n  $options,\n  $elemMatch,\n  $exists,\n};\nconst defaultInterpreters = {\n  eq,\n  ne,\n  lt,\n  lte,\n  gt,\n  gte,\n  in: within,\n  nin,\n  all,\n  size,\n  regex,\n  elemMatch,\n  exists,\n  and,\n};\n\ninterface MongoQueryFactory extends GenericFactory {\n  produce: MongoQuery<this[0]>\n}\n\ntype MergeUnion<T extends {}, Keys extends keyof T = keyof T> = { [K in Keys]: T[K] };\nexport type MongoQuery<T = AnyObject> = BuildMongoQuery<MergeUnion<T>, {\n  toplevel: {},\n  field: Pick<DefaultOperators<MergeUnion<T>>['field'], keyof typeof defaultInstructions>\n}> & Container<MongoQueryFactory>;\n\ntype MongoQueryMatcherFactory =\n  (...args: Partial<Parameters<typeof createFactory>>) => ConditionsMatcher<MongoQuery>;\nexport const buildMongoQueryMatcher = ((instructions, interpreters, options) => createFactory(\n  { ...defaultInstructions, ...instructions },\n  { ...defaultInterpreters, ...interpreters },\n  options\n)) as MongoQueryMatcherFactory;\n\nexport const mongoQueryMatcher = createFactory(defaultInstructions, defaultInterpreters);\nexport type {\n  MongoQueryFieldOperators,\n  MongoQueryTopLevelOperators,\n  MongoQueryOperators,\n} from '@ucast/mongo2js';\n","import { FieldMatcher } from '../types';\n\nconst REGEXP_SPECIAL_CHARS = /[-/\\\\^$+?.()|[\\]{}]/g;\nconst REGEXP_ANY = /\\.?\\*+\\.?/g;\nconst REGEXP_STARS = /\\*+/;\nconst REGEXP_DOT = /\\./g;\n\nfunction detectRegexpPattern(match: string, index: number, string: string): string {\n  const quantifier = string[0] === '*' || match[0] === '.' && match[match.length - 1] === '.'\n    ? '+'\n    : '*';\n  const matcher = match.indexOf('**') === -1 ? '[^.]' : '.';\n  const pattern = match.replace(REGEXP_DOT, '\\\\$&')\n    .replace(REGEXP_STARS, matcher + quantifier);\n\n  return index + match.length === string.length ? `(?:${pattern})?` : pattern;\n}\n\nfunction escapeRegexp(match: string, index: number, string: string): string {\n  if (match === '.' && (string[index - 1] === '*' || string[index + 1] === '*')) {\n    return match;\n  }\n\n  return `\\\\${match}`;\n}\n\nfunction createPattern(fields: string[]) {\n  const patterns = fields.map(field => field\n    .replace(REGEXP_SPECIAL_CHARS, escapeRegexp)\n    .replace(REGEXP_ANY, detectRegexpPattern));\n  const pattern = patterns.length > 1 ? `(?:${patterns.join('|')})` : patterns[0];\n\n  return new RegExp(`^${pattern}$`);\n}\n\nexport const fieldPatternMatcher: FieldMatcher = (fields) => {\n  let pattern: RegExp | null;\n\n  return (field) => {\n    if (typeof pattern === 'undefined') {\n      pattern = fields.every(f => f.indexOf('*') === -1)\n        ? null\n        : createPattern(fields);\n    }\n\n    return pattern === null\n      ? fields.indexOf(field) !== -1\n      : pattern.test(field);\n  };\n};\n","import { PureAbility, AbilityOptions } from './PureAbility';\nimport { RawRuleFrom } from './RawRule';\nimport { AbilityTuple } from './types';\nimport { MongoQuery, mongoQueryMatcher } from './matchers/conditions';\nimport { fieldPatternMatcher } from './matchers/field';\nimport { Public } from './RuleIndex';\n\nexport class Ability<\n  A extends AbilityTuple = AbilityTuple,\n  C extends MongoQuery = MongoQuery\n> extends PureAbility<A, C> {\n  constructor(rules: RawRuleFrom<A, C>[] = [], options: AbilityOptions<A, C> = {}) {\n    super(rules, {\n      conditionsMatcher: mongoQueryMatcher,\n      fieldMatcher: fieldPatternMatcher,\n      ...options,\n    });\n  }\n}\n\nexport interface AnyMongoAbility extends Public<Ability<any, MongoQuery>> {}\n","import { Ability, AnyMongoAbility } from './Ability';\nimport { AnyAbility, AbilityOptionsOf, AbilityClass } from './PureAbility';\nimport { RawRuleOf, Generics } from './RuleIndex';\nimport {\n  ExtractSubjectType as E,\n  AbilityTuple,\n  SubjectType,\n  TaggedInterface,\n  Normalize,\n  AnyObject,\n  AnyClass,\n} from './types';\nimport { ProduceGeneric } from './hkt';\n\nclass RuleBuilder<T extends AnyAbility> {\n  public _rule!: RawRuleOf<T>;\n\n  constructor(rule: RawRuleOf<T>) {\n    this._rule = rule;\n  }\n\n  because(reason: string): this {\n    this._rule.reason = reason;\n    return this;\n  }\n}\n\ntype InstanceOf<T extends AnyAbility, S extends SubjectType> = S extends AnyClass<infer R>\n  ? R\n  : S extends string\n    ? Exclude<Normalize<Generics<T>['abilities']>[1], SubjectType> extends TaggedInterface<string>\n      ? Extract<Normalize<Generics<T>['abilities']>[1], TaggedInterface<S>>\n      : AnyObject\n    : never;\ntype ConditionsOf<T extends AnyAbility, I extends {}> =\n  ProduceGeneric<Generics<T>['conditions'], I>;\ntype ActionFrom<T extends AbilityTuple, S extends SubjectType> = T extends any\n  ? S extends T[1] ? T[0] : never\n  : never;\ntype ActionOf<T extends AnyAbility, S extends SubjectType> = ActionFrom<Generics<T>['abilities'], S>;\ntype SubjectTypeOf<T extends AnyAbility> = E<Normalize<Generics<T>['abilities']>[1]>;\n\ntype SimpleCanParams<T extends AnyAbility> = Parameters<(\n  action: Generics<T>['abilities'] | Generics<T>['abilities'][]\n) => 0>;\ntype BuilderCanParameters<\n  S extends SubjectType,\n  I extends InstanceOf<T, S>,\n  T extends AnyAbility\n> = Generics<T>['abilities'] extends AbilityTuple\n  ? Parameters<(\n    action: ActionOf<T, S> | ActionOf<T, S>[],\n    subject: S | S[],\n    conditions?: ConditionsOf<T, I>\n  ) => 0>\n  : SimpleCanParams<T>;\n\ntype BuilderCanParametersWithFields<\n  S extends SubjectType,\n  I extends InstanceOf<T, S>,\n  F extends string,\n  T extends AnyAbility\n> = Generics<T>['abilities'] extends AbilityTuple\n  ? Parameters<(\n    action: ActionOf<T, S> | ActionOf<T, S>[],\n    subject: S | S[],\n    fields?: F | F[],\n    conditions?: ConditionsOf<T, I>\n  ) => 0>\n  : SimpleCanParams<T>;\ntype Keys<T> = string & keyof T;\n\nexport class AbilityBuilder<T extends AnyAbility> {\n  public rules: RawRuleOf<T>[] = [];\n  private _AbilityType!: AnyClass<T>;\n\n  constructor(AbilityType: AnyClass<T>) {\n    this._AbilityType = AbilityType;\n    this.can = this.can.bind(this as any);\n    this.cannot = this.cannot.bind(this as any);\n    this.build = this.build.bind(this as any);\n  }\n\n  can<\n    I extends InstanceOf<T, S>,\n    S extends SubjectTypeOf<T> = SubjectTypeOf<T>\n  >(...args: BuilderCanParameters<S, I, T>): RuleBuilder<T>\n  can<\n    I extends InstanceOf<T, S>,\n    F extends string = Keys<I>,\n    S extends SubjectTypeOf<T> = SubjectTypeOf<T>\n  >(...args: BuilderCanParametersWithFields<S, I, F | Keys<I>, T>): RuleBuilder<T>\n  can(\n    action: string | string[],\n    subject?: SubjectType | SubjectType[],\n    conditionsOrFields?: string | string[] | Generics<T>['conditions'],\n    conditions?: Generics<T>['conditions']\n  ): RuleBuilder<T> {\n    const rule = { action } as RawRuleOf<T>;\n\n    if (subject) {\n      rule.subject = subject;\n\n      if (Array.isArray(conditionsOrFields) || typeof conditionsOrFields === 'string') {\n        rule.fields = conditionsOrFields;\n      } else if (typeof conditionsOrFields !== 'undefined') {\n        rule.conditions = conditionsOrFields;\n      }\n\n      if (typeof conditions !== 'undefined') {\n        rule.conditions = conditions;\n      }\n    }\n\n    this.rules.push(rule);\n\n    return new RuleBuilder(rule);\n  }\n\n  cannot<\n    I extends InstanceOf<T, S>,\n    S extends SubjectTypeOf<T> = SubjectTypeOf<T>\n  >(...args: BuilderCanParameters<S, I, T>): RuleBuilder<T>\n  cannot<\n    I extends InstanceOf<T, S>,\n    F extends string = Keys<I>,\n    S extends SubjectTypeOf<T> = SubjectTypeOf<T>\n  >(...args: BuilderCanParametersWithFields<S, I, F | Keys<I>, T>): RuleBuilder<T>\n  cannot(\n    action: string | string[],\n    subject?: SubjectType | SubjectType[],\n    conditionsOrFields?: string | string[] | Generics<T>['conditions'],\n    conditions?: Generics<T>['conditions'],\n  ): RuleBuilder<T> {\n    const builder = (this as any).can(action, subject, conditionsOrFields, conditions);\n    builder._rule.inverted = true;\n    return builder;\n  }\n\n  build(options?: AbilityOptionsOf<T>) {\n    return new this._AbilityType(this.rules, options);\n  }\n}\n\ntype DSL<T extends AnyAbility, R> = (\n  can: AbilityBuilder<T>['can'],\n  cannot: AbilityBuilder<T>['cannot']\n) => R;\n\nexport function defineAbility<\n  T extends AnyMongoAbility\n>(define: DSL<T, Promise<void>>, options?: AbilityOptionsOf<T>): Promise<T>;\nexport function defineAbility<\n  T extends AnyMongoAbility\n>(define: DSL<T, void>, options?: AbilityOptionsOf<T>): T;\nexport function defineAbility<\n  T extends AnyMongoAbility\n>(define: DSL<T, void | Promise<void>>, options?: AbilityOptionsOf<T>): T | Promise<T> {\n  const builder = new AbilityBuilder(Ability as unknown as AbilityClass<T>);\n  const result = define(builder.can, builder.cannot);\n\n  if (result && typeof result.then === 'function') {\n    return result.then(() => builder.build(options));\n  }\n\n  return builder.build(options);\n}\n","import { AnyAbility } from './PureAbility';\nimport { Normalize } from './types';\nimport { Generics } from './RuleIndex';\nimport { getSubjectTypeName } from './utils';\n\nexport type GetErrorMessage = (error: ForbiddenError<AnyAbility>) => string;\nexport const getDefaultErrorMessage: GetErrorMessage = error => `Cannot execute \"${error.action}\" on \"${error.subjectType}\"`;\n\nconst NativeError = function NError(this: Error, message: string) {\n  this.message = message;\n} as unknown as new (message: string) => Error;\n\nNativeError.prototype = Object.create(Error.prototype);\n\nexport class ForbiddenError<T extends AnyAbility> extends NativeError {\n  public readonly ability!: T;\n  public action!: Normalize<Generics<T>['abilities']>[0];\n  public subject!: Generics<T>['abilities'][1];\n  public field?: string;\n  public subjectType!: string;\n\n  static _defaultErrorMessage = getDefaultErrorMessage;\n\n  static setDefaultMessage(messageOrFn: string | GetErrorMessage) {\n    this._defaultErrorMessage = typeof messageOrFn === 'string' ? () => messageOrFn : messageOrFn;\n  }\n\n  static from<U extends AnyAbility>(ability: U) {\n    return new this<U>(ability);\n  }\n\n  private constructor(ability: T) {\n    super('');\n    this.ability = ability;\n\n    if (typeof Error.captureStackTrace === 'function') {\n      this.name = 'ForbiddenError';\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n\n  setMessage(message: string) {\n    this.message = message;\n    return this;\n  }\n\n  throwUnlessCan(...args: Parameters<T['can']>) {\n    const rule = this.ability.relevantRuleFor(...args);\n\n    if (rule && !rule.inverted) {\n      return;\n    }\n\n    this.action = args[0];\n    this.subject = args[1];\n    this.subjectType = getSubjectTypeName(this.ability.detectSubjectType(args[1]));\n    this.field = args[2];\n\n    const reason = rule ? rule.reason : '';\n    // eslint-disable-next-line no-underscore-dangle\n    this.message = this.message || reason || (this.constructor as any)._defaultErrorMessage(this);\n    throw this; // eslint-disable-line\n  }\n}\n"],"names":["wrapArray","value","Array","isArray","TYPE_FIELD","setSubjectType","type","object","hasOwnProperty","Object","defineProperty","Error","isSubjectType","getSubjectClassName","modelName","name","getSubjectTypeName","detectSubjectType","subject","constructor","expandActions","aliasMap","rawActions","merge","actions","i","length","action","findDuplicate","actionToFind","indexOf","defaultAliasMerge","concat","validateForCycles","reservedAction","keys","mergeAliasesAndDetectCycles","duplicate","join","isUsingReservedAction","createAliasResolver","options","skipValidate","anyAction","copyArrayTo","dest","target","start","push","mergePrioritized","array","anotherArray","j","merged","priority","getOrDefault","map","key","defaultValue","get","set","identity","x","validate","rule","fields","fieldMatcher","conditions","conditionsMatcher","Rule","resolveAction","inverted","reason","undefined","_options","_conditionsMatcher","_matchConditions","matchesConditions","matches","matchesField","field","_matchField","ast","linkedItem","prev","item","next","unlinkItem","cloneLinkedItem","defaultActionEntry","rules","defaultSubjectEntry","Map","analyze","index","_hasPerFieldRules","RuleIndex","_events","_ruleOptions","_anyAction","_anySubjectType","anySubjectType","_detectSubjectType","_rules","_indexedRules","_buildIndexFor","update","event","ability","_emit","rawRules","indexedRules","subjects","k","subjectRules","possibleRulesFor","subjectType","actionRules","anyActionRules","has","rulesFor","filter","on","handler","tail","currentTail","delete","payload","current","PureAbility","can","relevantRuleFor","cannot","defaultInstructions","$eq","$ne","$lt","$lte","$gt","$gte","$in","$nin","$all","$size","$regex","$options","$elemMatch","$exists","defaultInterpreters","eq","ne","lt","lte","gt","gte","in","within","nin","all","size","regex","elemMatch","exists","and","buildMongoQueryMatcher","instructions","interpreters","createFactory","mongoQueryMatcher","REGEXP_SPECIAL_CHARS","REGEXP_ANY","REGEXP_STARS","REGEXP_DOT","detectRegexpPattern","match","string","quantifier","matcher","pattern","replace","escapeRegexp","createPattern","patterns","RegExp","fieldPatternMatcher","every","f","test","Ability","RuleBuilder","_rule","because","AbilityBuilder","AbilityType","_AbilityType","bind","build","conditionsOrFields","builder","defineAbility","define","result","then","getDefaultErrorMessage","error","NativeError","NError","message","prototype","create","ForbiddenError","setDefaultMessage","messageOrFn","_defaultErrorMessage","from","captureStackTrace","setMessage","throwUnlessCan"],"mappings":"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"}